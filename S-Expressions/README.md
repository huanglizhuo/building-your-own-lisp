##列表和lisp

  lisp 因它的数据和代码基本没有区别而知名。它们都是由同样的结构表示。这就让 lisp 具有了其它语言所没有的强大威力。如果想把这种特性加入到我们的编程语言中，我们需要把读入和计算分开。

  这章最后的结果和前面的章节有些不同。因为我们将要改变内部处理代码的过程。这叫做做 re-factoring 这会让我们之后的工作更轻松。像准备晚餐一样，我们把食物摆在盘子里不代表我们在浪费时间。有时候期待晚餐比吃晚餐更美好。

  ![All CAPS SO RIGHT YET SO WRONG](./lisp.png)

  我们需要建立一张有数字符号和列表递归构建内部列表来存储我们的代码。在 Lisp 中这个结构体叫做 S 表达式  Symbolic Expression(符号表达式)。我们将会扩展我们的 `lval` 结构体来表示它。评估 S表达式的过程是 lisp 语言的典型过程。评估一个S表达式，我们首先把列表的第一个表项当做操作符。然后遍历剩下的表项，并把它们当做操作数来最后得到结果。

  介绍过S表达式后，我们将正真进入到Lisp的世界。

##指针

  在C语言中列表的概念是通过合适的指针操作实现的。指针是C语言的难点。指针很难学因为它的概念很简单，但有很多新术语，而且经常没有很明确的用例。这让指针的概念变的异常麻烦。幸运的是，我们有很多很好的用例，它们都是C中典型的，而且会囊括指针90%的用法。

  我们需要指针的原因是由于函数调用的工作方式，当你在C中调用函数时参数往往是按值传递的。就是说传给函数的是一个拷贝而已。比如`int` `long` `char` 以及自定义的结构体 `lval` 都是。大多数情形下都没有问题但有时候会带来麻烦。

  最通常的一个问题就是当我们想给函数传递一个很大的机构体时，每次我们调用函数时都要复制一份这个结构体，这样就会耗费大量的空间。

  A second problem is this. When we define a struct, it is always a fixed size. It has a limited number of fields, and each of these fields must be a struct which itself is limited in size. If I want to call a function with just a list of things, where the number of things varies from call to call, clearly I can't use a struct to do this.

 为了解决这些问题，C 语言想出了一个很聪明的办法。它把计算机内存想象成一个巨大的比特列表。这个列表中每个比特位都有一个全局的索引。每个比特就像是个房间号。

  在这种情形下计算机内所有的数据包括结构体和变量，在列表中都有一个开头。相对于把一个数据复制一份传给函数，我们更倾向于传递数据起始的索引，函数就可以读取任何数量的数据了。

  通过使用地址，函数就可以不用复制任何数据来访问和需改内存中的数据了。函数通过指针也可以做到其它的一些事情，比如把数据输出到输入地址的指定地址中。

  因为计算机总内存大小是可变的，地址的比特值表示的地址位置必须是不变的。但如果我们不断记录它的话，地址指针的比特数可能增长或者缩减。这意味着我们可以创建大小可变的数据结构并把它传给函数，在函数中可以对它进行检查和修改。

  因此指针就是一个数字，这个数字代表内存中某个数据的起始地址。指针的类型告诉我们和编译器，这个位置的数据的类型是什么。

  用类型名加`*`声明指针。之前我们已经见过了比如`mpc_parser_t*`,`mpc_ast_t*`,`char*`

  创建某个类型的指针首先得得到它的索引或者地址，用`&`可以取得。

  最后是如何得到某个地址的数据，又叫做引用，使用`*`取得地址的内容。获取指针某个属性使用`->`操作符。

##栈和堆
