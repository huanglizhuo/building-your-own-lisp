#崩溃

  你可能注意到前面章节的问题。试着把下面的代码输入到程序中，看看发生了什么。

  ```c
Lispy Version 0.0.0.0.3
Press Ctrl+c to Exit

lispy> / 10 0
  ```

  oh no 因为除零程序崩溃了！！！程序开发时崩溃还好，但最终程序最好用不崩溃，并可以告诉用户哪里出问题了。这时候我们的程序产可以预测语法错误但仍然没有在计算表达式时报告错误的函数。我们需要建立一些错误处理机制来函数式的处理错误。在C语言中这有些尴尬，但如果从正确的轨道开始，会对我们后面程序变的复杂时有很大的好处。

  C程序如果有任何错误操作系统就会把它踢出去。程序崩溃的原因有很多，并且方式也都不一样。

  但C程序运行中并没有什么魔法，如果你遇到一些艰难的bug不要放弃或者死死盯着它，这时你应该学习一下`gdb`和`valgrind`。这些是很强大的工具，在初始学习后，你会发现它们会节省你大量的时间。

  ![Walter White heisenberg][./walterwhite.png]

#lisp值

  在C语言中有很对处理错误的方式，但这里我推荐返回一个计算的可能值。这样就可以做到在 lispy ，一个表达式的结果要么是一个数字要么是一个错误。比如`+ 1 2` 返回一个数字，而`/ 10 0` 返回一个错误。

  为了做到这一点，我们需要一个数据结构可，要么是任何值要么是一个特定的值。最简单的方式就是用一个带有一个可以放任何值的属性并且可以呈现出来，一个一个`type`属性来给出哪些是由意义的属性。

  接下来我们打算叫它`lval`，代表 lisp 类型。

  ```c
    typedef struct{
        int type;
        int num;
        int err;
    }lval;
  ```

#枚举

  你可能注意到了`type` `err`字段的类型是 `int` 。

  我们之所以用`int`是因为我们将会给每个整数值赋予对应的意义。比如可以定义这样的规则如果`type`是`0`那么就是一个数字，或者如果`type`是`1`那么就是`error` 。

  但如果后面忘记这个对应的意义就会很麻烦，对此我们可以用命名常量来标识它。这样在比较的时候就可可以清楚的知道对应的值以及上下文了。

  在C语言中可以使用`enum`

  ```c

    enum{ LVAL_NUM, LVAL_ERR};
  ```

  每个`enum`会自动分配一个整数值。
  
  我们也可以定义一些错误类型，来表示除零错误溢出错误等。

  ```c
enum { LERR_DIV_ZERO, LERR_BAD_OP, LERR_BAD_NUM };
  ```

#lisp类型函数
